// package validator_v1 implements a validator communication protocol.
// Validator firmware is implementing the server while Apollo daemon
// implements the client.

syntax = "proto3";
package validator.v1;

option go_package = "apis/validator/v1";

service ValidatorService {
  // StreamReaderEvents is a subscription type handler where TS client subscribes
  // to card tap events
  rpc StreamReaderEvents(StreamReaderEventsRequest) returns  (stream StreamReaderEventsResponse) {}

  rpc CardWrite(CardWriteRequest) returns (CardWriteResponse) {}

  // Display is used to request validator firmware to open an HTML link or just
  // display the given HTML contents.
  rpc Display(DisplayRequest) returns (DisplayResponse) {}

  // PlaySound is used to request validator firmware to play specified
  // file through the internal speakers
  rpc PlaySound(PlaySoundRequest) returns (PlaySoundResponse) {}

  // SetConfiguration is used to set configuration such as read/write sectors and keys
  // to the validator firmware.
  rpc SetConfiguration(SetConfigurationRequest) returns (SetConfigurationResponse) {}

  // GetConfiguration returns current validator firmware configuration. It includes information such
  // as read/write sector info.
  rpc GetConfiguration(GetConfigurationRequest) returns (GetConfigurationResponse) {}

  // GetStatus returns current status of the system. In normal operation VALIDATOR_STATUS_ACTIVE
  // will be returned which means that it's okay to validate users
  rpc GetStatus(GetStatusRequest) returns (GetStatusResponse) {}

  rpc RestartCardReader(RestartCardReaderRequest) returns (RestartCardReaderResponse) {}

  rpc Restart(RestartRequest) returns (RestartResponse) {}

  rpc ProcessEmvCard(ProcessEmvCardRequest) returns (ProcessEmvCardResponse) {}
}

message StreamReaderEventsRequest {}

// Identifiable card types
enum CardType {
  CARD_TYPE_UNSPECIFIED = 0;
  CARD_TYPE_MIFARE4K    = 1;
  CARD_TYPE_MIFARE1K    = 2;
  CARD_TYPE_ULTRALIGHT  = 3;
  CARD_TYPE_DESFIRE     = 4;
  CARD_TYPE_PLUS        = 5;
  CARD_TYPE_EMV         = 6;
  CARD_TYPE_UNKNOWN     = 7;
  CARD_TYPE_BARCODE     = 8;
}

// ValidateRequest is a request sent by the validator to the onboard node
// for the card/ticket validation
message StreamReaderEventsResponse {
  enum ReadEventType {
    READ_EVENT_TYPE_UNSPECIFIED         = 0;
    READ_EVENT_TYPE_OK                  = 1; // all ok, mifare: block data ready / emv: transaction successful
    READ_EVENT_TYPE_UNSPECIFIED_ERROR   = 2; // any other error than the ones below
    READ_EVENT_TYPE_UNKNOWN_CARD_TYPE   = 3; // not a Mifare 4k card
    READ_EVENT_TYPE_WRONG_KEY           = 4; // auth failed, probably not "our" card
    READ_EVENT_TYPE_PERMISSIONS         = 5; // auth succeeded, but cannot read (incorrect card config)
    READ_EVENT_TYPE_INVALID_DATA        = 6; // both blocks contain invalid data (new card or fraud)
    READ_EVENT_TYPE_EMV_TAP             = 7; // emv card detected
  }
  ReadEventType       read_event_type = 1;
  bytes               identifier      = 2; // mifare: uid / emv: token
  bytes               block_data      = 3; // mifare: data read using info provided by GetConfigurationResponse readSector & readSecodKey / emv: empty
  CardType            type            = 4; // type of the user device
  map<string, string> metadata        = 5; // gps coords, stop_id, distance, etc..
  string              error_message   = 6; // optional message for the error
  string              session_id      = 7; // mifare: empty / emv: session ud (uuid) generated by validator
}

message CardWriteRequest {
  bytes block_data  = 1;
  string session_id = 2; // private/TA-internal/emv-only: session id from StreamReaderEventsResponse
}

message CardWriteResponse {
  enum WriteStatus {
    WRITE_STATUS_UNSPECIFIED       = 0;
    WRITE_STATUS_SUCCESS           = 1;
    WRITE_STATUS_UNSPECIFIED_ERROR = 2;
    WRITE_STATUS_WRONG_PERMISSIONS = 3;
  }
  WriteStatus status        = 1; // write status
  string      error_message = 2; // optional message for the error
}

message SetConfigurationRequest {
  uint64 sector          = 1;
  uint64 primary_block   = 2;
  uint64 secondary_block = 3;
  bytes  sector_key      = 4;
  // unix_nano is current time as a Unix time, the number of nanoseconds elapsed
  // since January 1, 1970 UTC.
  int64  unix_nano       = 5;
  int64 nfc_write_timeout_ms = 6; // For non EMV cards how long to wait for CardWrite event.
  int64 emv_tap_callback_timeout_ms = 7; // How many milliseconds to wait for ProcessEmvCard event.
}

message SetConfigurationResponse {}

message GetConfigurationRequest {}

// GetConfigurationResponse is returned by the node
// to validator to indicate which sector of the card to read during
// the validation
message GetConfigurationResponse {
  uint64 sector          = 1;
  uint64 primary_block   = 2;
  uint64 secondary_block = 3;
  bytes  sector_key      = 4;
  // unix_nano is current time as a Unix time, the number of nanoseconds elapsed
  // since January 1, 1970 UTC.
  int64  unix_nano       = 5; // superseded by GetStatusResponse.unix_nano
  int64 nfc_write_timeout_ms = 6;
  bool emv_enabled = 7; // TODO 874 TLU: `true` if EMV is enabled.
  int64 emv_tap_callback_timeout_ms = 8;
}

message DisplayRequest {
  string url      = 1;
  string session_id = 2; // private/TA-internal/emv-only: session id from StreamReaderEventsResponse
}

message DisplayResponse {}

message PlaySoundRequest {
  string filepath = 2;
  string session_id = 3; // private/TA-internal/emv-only: session id from StreamReaderEventsResponse
}

message PlaySoundResponse {}

message GetStatusRequest {}

message EmvStatus {
  string terminal_id = 1; // emv terminal identifier
  string bank_app_version = 2; // emv terminal bank application version.
  string maintenance_app_version = 3; // emv terminal maintenance application version.
  int64 unix_nano = 4; // emv terminal current system date/time.
  map<string, string> metadata = 5; // ?? optional: should contain non secured configs e.g. last blacklisted cards synchronisation time, last (re)start time etc.
}

// GetStatusResponse is used by the node daemon to provide status
// to the validator
message GetStatusResponse {
  enum Status {
    STATUS_UNSPECIFIED = 0;
    STATUS_ACTIVE      = 1;
    STATUS_INACTIVE    = 2;
    STATUS_STARTING    = 3; // until the SetConfiguration is called
  }
  string currently_displaying     = 1; // Currently displayed (URL or filepath)
  Status status                   = 2;
  string message                  = 3; // optional, under normal circumstances it will be empty
  int64  unix_nano                  = 4; // validator current system date/time
  string validator_id               = 5; // validator unique-id/serial-no
  string validator_software_version = 6; // validator app-version
  EmvStatus emv_status              = 7; // emv status
}

message RestartCardReaderRequest {}
message RestartCardReaderResponse {}

message RestartRequest {}
message RestartResponse {}

message ProcessEmvCardRequest {
  enum Action {
    ACTION_UNSPECIFIED = 0;
    ACTION_PROCEED = 1;
    ACTION_IGNORE = 2;
  }
  Action action = 1;
  string session_id = 2; // session id from StreamReaderEventsResponse
  bytes trip_data = 3; // backoffice known structure (binary byte array)
}

message ProcessEmvCardResponse {}
