// package validator_v1 implements a validator <-> onboard PC communication
// protocol. All RPC methods should be accompanied by a header with 
// the validator ID. Calls that don't provide the header, will be rejected

syntax = "proto3";
package github.com.apollohq.fleetnodedaemon.apis.validator_v1;

service Validator {
  rpc ListValidationMessages(ValidationMessageRequest) returns (ListValidationMessageResponse) {}
  rpc ListValidationSounds(ValidationSoundRequest) returns (ListValidationSoundResponse) {}

  rpc GetConfiguration(ValidatorConfigurationRequest) returns (ValidatorConfigurationResponse) {}
  // ListValidationErrors returns a list of images, messages and sounds to use during certain errors
  // that happen before or after Validate transactions. 
  rpc ListValidationErrors(ValidationErrorsRequest) returns (ListValidationErrorsResponse) {}

  // Validates a card (under the hood it will either buy a single day ticket 
  // or check whether user already has monthly ticket)
  rpc Validate(ValidateRequest) returns (ValidateResponse) {}

  // GetStatus returns current status of the system. In normal operation VALIDATOR_STATUS_ACTIVE
  // will be returned which means that it's okay to validate users
  rpc GetStatus(StatusRequest) returns (StatusResponse) {}
}

message ValidationMessageRequest {}

message ListValidationMessageResponse {
  repeated ValidationMessage messages = 1;
}

// ValidationMessage is a validation message type. There can be multiple message
// types returned from via the RPC method
message ValidationMessage {
  uint64 id            = 1; // message ID
  string text          = 2; // alternative text
  bytes  image         = 3; // image bytes
  string imageChecksum = 4; // md5 checksum of the image
  int64  updated       = 5; // last updated unix timestamp
}

message ValidationSoundRequest {}

message ListValidationSoundResponse {
  repeated ValidationSound sounds = 1;
}

message ValidationSound {
  uint64 id            = 1; // sound ID
  bytes  sound         = 2; // validation bytes
  string soundChecksum = 4; // md5 checksum of the sound
  int64  updated       = 5; // last updated unix timestamp
}

message ValidatorConfigurationRequest {}

// ValidatorConfigurationResponse is returned by the node
// to validator to indicate which sector of the card to read during
// the validation
message ValidatorConfigurationResponse {
  uint64 readSector     = 1;
  bytes  readSectorKey  = 2;
  uint64 writeSector    = 3;
  bytes  writeSectorKey = 4;
}

// ValidateRequest is a request sent by the validator to the onboard node
// for the card/ticket validation
message ValidateRequest {
  string              identifier = 1; // mifare, for example '3059947987'
  enum Type {
    // 0 is reserved for unknown
    UNKNOWN      = 0;
    MIFARE       = 1;
    RFID         = 2;
  };
  Type                type       = 2; // token type (card, rfid)
  bytes               blockData  = 3; // data read using info provided by ValidatorConfigurationResponse readSector & readSecodKey
  map<string, string> metadata   = 4; // gps coords, stop_id, distance, etc..
}

// ValidateResponse is a response returned by the onboard node to the validator
message ValidateResponse {
  enum Status {
    // 0 is reserved for errors
    UNKNOWN      = 0;
    OK           = 1;
    ERROR        = 2;
    SERVER_ERROR = 3;
  };
  Status status      = 1; // generic status
  uint64 soundId     = 2; // which sound ID to play
  uint64 messageId   = 3; // which message image to show
  string messageText = 4; // optionally used together with the messageId when showing 'Valid till 2019-09-29'

  uint64 sector      = 5; // sector where to write the data
  bytes  blockData   = 6; // data payload
}

message ValidationErrorsRequest {}

// ListValidatorErrorsResponse represents a list of messages & images that can be displayed
// on the validator screen when errors occure (for example validator successfully validated
// a card but failed to write data to a card)
message ListValidationErrorsResponse {
  repeated ValidationError errors = 1;
}

enum ValidationErrorReason {
  // Errors encountered server side. In this case it won't mean much to the validator itself
  // so soundId, messageId and messageText can be used to give feedback to the user
  VALIDATION_ERROR_REASON_INTERNAL_SERVER    = 0; 
  // Errors that might get encountered by the validator itself, for example
  // after the validation when it's writing blockData to the sector and failing (user has
  // taken back the card) - 
  VALIDATION_ERROR_REASON_CARD_WRITE_FAILED  = 1; 
  VALIDATION_ERROR_REASON_CARD_READ_FAILED   = 2;
  VALIDATION_ERROR_REASON_UNKNOWN_CARD       = 3;
  // TODO: add any other error types here that the validator client side
  // might encounter
}

message ValidationError {
  uint64                id          = 1;
  ValidationErrorReason reason      = 2;  // example: VALIDATION_ERROR_REASON_CARD_WRITE_FAILED
  uint64                soundId     = 3;
  uint64                messageId   = 4;
  uint64                messageText = 5;
}

message StatusRequest {}

enum ValidatorStatus {
  VALIDATOR_STATUS_UNKNOWN     = 0;
  VALIDATOR_STATUS_ACTIVE      = 1;
  VALIDATOR_STATUS_LOCKED      = 2;
  VALIDATOR_STATUS_SUSPENDED   = 3;
  VALIDATOR_STATUS_OFFLINE     = 4;
}

// StatusResponse is used by the node daemon to provide status
// to the validator, based on which it would display some message
// when it's operational and some other message when it's offline or 
// locked by the inspector
message StatusResponse {
  ValidatorStatus status  = 1;
  uint64 messageId        = 3; // which message image to show
  string messageText      = 4; // optionally used together with the messageId
}